async function streamToText(stream) {
  let accumulatedContent = "";
  for await (const chunk of stream) {
    if (chunk.type === "content" && chunk.delta) {
      accumulatedContent += chunk.delta;
    }
  }
  return accumulatedContent;
}
function toServerSentEventsStream(stream, abortController) {
  const encoder = new TextEncoder();
  return new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of stream) {
          if (abortController?.signal.aborted) {
            break;
          }
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(chunk)}

`)
          );
        }
        controller.enqueue(encoder.encode("data: [DONE]\n\n"));
        controller.close();
      } catch (error) {
        if (abortController?.signal.aborted) {
          controller.close();
          return;
        }
        controller.enqueue(
          encoder.encode(
            `data: ${JSON.stringify({
              type: "error",
              error: {
                message: error.message || "Unknown error occurred",
                code: error.code
              }
            })}

`
          )
        );
        controller.close();
      }
    },
    cancel() {
      if (abortController) {
        abortController.abort();
      }
    }
  });
}
function toServerSentEventsResponse(stream, init) {
  const { headers, abortController, ...responseInit } = init ?? {};
  const mergedHeaders = new Headers({
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive"
  });
  if (headers) {
    const userHeaders = new Headers(headers);
    userHeaders.forEach((value, key) => {
      mergedHeaders.set(key, value);
    });
  }
  return new Response(toServerSentEventsStream(stream, abortController), {
    ...responseInit,
    headers: mergedHeaders
  });
}
function toHttpStream(stream, abortController) {
  const encoder = new TextEncoder();
  return new ReadableStream({
    async start(controller) {
      try {
        for await (const chunk of stream) {
          if (abortController?.signal.aborted) {
            break;
          }
          controller.enqueue(encoder.encode(`${JSON.stringify(chunk)}
`));
        }
        controller.close();
      } catch (error) {
        if (abortController?.signal.aborted) {
          controller.close();
          return;
        }
        controller.enqueue(
          encoder.encode(
            `${JSON.stringify({
              type: "error",
              error: {
                message: error.message || "Unknown error occurred",
                code: error.code
              }
            })}
`
          )
        );
        controller.close();
      }
    },
    cancel() {
      if (abortController) {
        abortController.abort();
      }
    }
  });
}
function toHttpResponse(stream, init) {
  return new Response(toHttpStream(stream, init?.abortController), {
    ...init
  });
}
export {
  streamToText,
  toHttpResponse,
  toHttpStream,
  toServerSentEventsResponse,
  toServerSentEventsStream
};
//# sourceMappingURL=stream-to-response.js.map
