function isStandardJSONSchema(schema) {
  return typeof schema === "object" && schema !== null && "~standard" in schema && typeof schema["~standard"] === "object" && schema["~standard"].version === 1 && typeof schema["~standard"].jsonSchema === "object" && typeof schema["~standard"].jsonSchema.input === "function";
}
function isStandardSchema(schema) {
  return typeof schema === "object" && schema !== null && "~standard" in schema && typeof schema["~standard"] === "object" && schema !== null && schema["~standard"] !== null && "version" in schema["~standard"] && schema["~standard"].version === 1 && "validate" in schema["~standard"] && typeof schema["~standard"].validate === "function";
}
function makeStructuredOutputCompatible(schema, originalRequired = []) {
  const result = { ...schema };
  if (result.type === "object" && result.properties) {
    const properties = { ...result.properties };
    const allPropertyNames = Object.keys(properties);
    for (const propName of allPropertyNames) {
      const prop = properties[propName];
      const wasOptional = !originalRequired.includes(propName);
      if (prop.type === "object" && prop.properties) {
        properties[propName] = makeStructuredOutputCompatible(
          prop,
          prop.required || []
        );
      } else if (prop.type === "array" && prop.items) {
        properties[propName] = {
          ...prop,
          items: makeStructuredOutputCompatible(
            prop.items,
            prop.items.required || []
          )
        };
      } else if (wasOptional) {
        if (prop.type && !Array.isArray(prop.type)) {
          properties[propName] = {
            ...prop,
            type: [prop.type, "null"]
          };
        } else if (Array.isArray(prop.type) && !prop.type.includes("null")) {
          properties[propName] = {
            ...prop,
            type: [...prop.type, "null"]
          };
        }
      }
    }
    result.properties = properties;
    result.required = allPropertyNames;
    result.additionalProperties = false;
  }
  if (result.type === "array" && result.items) {
    result.items = makeStructuredOutputCompatible(
      result.items,
      result.items.required || []
    );
  }
  return result;
}
function convertSchemaToJsonSchema(schema, options = {}) {
  if (!schema) return void 0;
  const { forStructuredOutput = false } = options;
  if (isStandardJSONSchema(schema)) {
    const jsonSchema = schema["~standard"].jsonSchema.input({
      target: "draft-07"
    });
    let result = jsonSchema;
    if (typeof result === "object" && "$schema" in result) {
      const { $schema, ...rest } = result;
      result = rest;
    }
    if (typeof result === "object") {
      if ("properties" in result && !result.type) {
        result.type = "object";
      }
      if (result.type === "object" && !("properties" in result)) {
        result.properties = {};
      }
      if (result.type === "object" && !("required" in result)) {
        result.required = [];
      }
      if (forStructuredOutput) {
        result = makeStructuredOutputCompatible(
          result,
          result.required || []
        );
      }
    }
    return result;
  }
  if (forStructuredOutput && typeof schema === "object") {
    return makeStructuredOutputCompatible(
      schema,
      schema.required || []
    );
  }
  return schema;
}
function parseWithStandardSchema(schema, data) {
  if (!isStandardSchema(schema)) {
    return data;
  }
  const result = schema["~standard"].validate(data);
  if (result instanceof Promise) {
    throw new Error(
      "Schema validation returned a Promise. Use validateWithStandardSchema for async validation."
    );
  }
  if (!result.issues) {
    return result.value;
  }
  const errorMessages = result.issues.map((issue) => issue.message || "Validation failed").join(", ");
  throw new Error(`Validation failed: ${errorMessages}`);
}
export {
  convertSchemaToJsonSchema,
  isStandardJSONSchema,
  isStandardSchema,
  parseWithStandardSchema
};
//# sourceMappingURL=schema-converter.js.map
