{"version":3,"file":"tool-definition.js","sources":["../../../../../src/activities/chat/tools/tool-definition.ts"],"sourcesContent":["import type { StandardJSONSchemaV1 } from '@standard-schema/spec'\nimport type {\n  InferSchemaType,\n  JSONSchema,\n  SchemaInput,\n  Tool,\n} from '../../../types'\n\n/**\n * Marker type for server-side tools\n */\nexport interface ServerTool<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n> extends Tool<TInput, TOutput, TName> {\n  __toolSide: 'server'\n}\n\n/**\n * Marker type for client-side tools\n */\nexport interface ClientTool<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n> {\n  __toolSide: 'client'\n  name: TName\n  description: string\n  inputSchema?: TInput\n  outputSchema?: TOutput\n  needsApproval?: boolean\n  metadata?: Record<string, unknown>\n  execute?: (\n    args: InferSchemaType<TInput>,\n  ) => Promise<InferSchemaType<TOutput>> | InferSchemaType<TOutput>\n}\n\n/**\n * Tool definition that can be used directly or instantiated for server/client\n */\nexport interface ToolDefinitionInstance<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n> extends Tool<TInput, TOutput, TName> {\n  __toolSide: 'definition'\n}\n\n/**\n * Union type for any kind of client-side tool (client tool or definition)\n */\nexport type AnyClientTool =\n  | ClientTool<SchemaInput, SchemaInput>\n  | ToolDefinitionInstance<SchemaInput, SchemaInput>\n\n/**\n * Extract the tool name as a literal type\n */\nexport type InferToolName<T> = T extends { name: infer N } ? N : never\n\n/**\n * Extract the input type from a tool (inferred from Standard JSON Schema, or `unknown` for plain JSONSchema)\n */\nexport type InferToolInput<T> = T extends { inputSchema?: infer TInput }\n  ? TInput extends StandardJSONSchemaV1<infer TInferred, unknown>\n    ? TInferred\n    : TInput extends JSONSchema\n      ? unknown\n      : unknown\n  : unknown\n\n/**\n * Extract the output type from a tool (inferred from Standard JSON Schema, or `unknown` for plain JSONSchema)\n */\nexport type InferToolOutput<T> = T extends { outputSchema?: infer TOutput }\n  ? TOutput extends StandardJSONSchemaV1<infer TInferred, unknown>\n    ? TInferred\n    : TOutput extends JSONSchema\n      ? unknown\n      : unknown\n  : unknown\n\n/**\n * Tool definition configuration\n */\nexport interface ToolDefinitionConfig<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n> {\n  name: TName\n  description: string\n  inputSchema?: TInput\n  outputSchema?: TOutput\n  needsApproval?: boolean\n  metadata?: Record<string, unknown>\n}\n\n/**\n * Tool definition builder that allows creating server or client tools from a shared definition\n */\nexport interface ToolDefinition<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n> extends ToolDefinitionInstance<TInput, TOutput, TName> {\n  /**\n   * Create a server-side tool with execute function\n   */\n  server: (\n    execute: (\n      args: InferSchemaType<TInput>,\n    ) => Promise<InferSchemaType<TOutput>> | InferSchemaType<TOutput>,\n  ) => ServerTool<TInput, TOutput, TName>\n\n  /**\n   * Create a client-side tool with optional execute function\n   */\n  client: (\n    execute?: (\n      args: InferSchemaType<TInput>,\n    ) => Promise<InferSchemaType<TOutput>> | InferSchemaType<TOutput>,\n  ) => ClientTool<TInput, TOutput, TName>\n}\n\n/**\n * Create an isomorphic tool definition that can be used directly or instantiated for server/client\n *\n * The definition contains all tool metadata (name, description, schemas) and can be:\n * 1. Used directly in chat() on the server (as a tool definition without execute)\n * 2. Instantiated as a server tool with .server()\n * 3. Instantiated as a client tool with .client()\n *\n * Supports any Standard JSON Schema compliant library (Zod v4+, ArkType, Valibot, etc.)\n * or plain JSON Schema objects.\n *\n * @example\n * ```typescript\n * import { toolDefinition } from '@tanstack/ai';\n * import { z } from 'zod';\n *\n * // Using Zod (natively supports Standard JSON Schema)\n * const addToCartTool = toolDefinition({\n *   name: 'addToCart',\n *   description: 'Add a guitar to the shopping cart (requires approval)',\n *   needsApproval: true,\n *   inputSchema: z.object({\n *     guitarId: z.string(),\n *     quantity: z.number(),\n *   }),\n *   outputSchema: z.object({\n *     success: z.boolean(),\n *     cartId: z.string(),\n *     totalItems: z.number(),\n *   }),\n * });\n *\n * // Use directly in chat (server-side, no execute function)\n * chat({\n *   tools: [addToCartTool],\n *   // ...\n * });\n *\n * // Or create server-side implementation\n * const addToCartServer = addToCartTool.server(async (args) => {\n *   // args is typed as { guitarId: string; quantity: number }\n *   return {\n *     success: true,\n *     cartId: 'CART_' + Date.now(),\n *     totalItems: args.quantity,\n *   };\n * });\n *\n * // Or create client-side implementation\n * const addToCartClient = addToCartTool.client(async (args) => {\n *   // Client-specific logic (e.g., localStorage)\n *   return { success: true, cartId: 'local', totalItems: 1 };\n * });\n * ```\n */\nexport function toolDefinition<\n  TInput extends SchemaInput = SchemaInput,\n  TOutput extends SchemaInput = SchemaInput,\n  TName extends string = string,\n>(\n  config: ToolDefinitionConfig<TInput, TOutput, TName>,\n): ToolDefinition<TInput, TOutput, TName> {\n  const definition: ToolDefinition<TInput, TOutput, TName> = {\n    __toolSide: 'definition',\n    ...config,\n    server(\n      execute: (\n        args: InferSchemaType<TInput>,\n      ) => Promise<InferSchemaType<TOutput>> | InferSchemaType<TOutput>,\n    ): ServerTool<TInput, TOutput, TName> {\n      return {\n        __toolSide: 'server',\n        ...config,\n        execute,\n      }\n    },\n\n    client(\n      execute?: (\n        args: InferSchemaType<TInput>,\n      ) => Promise<InferSchemaType<TOutput>> | InferSchemaType<TOutput>,\n    ): ClientTool<TInput, TOutput, TName> {\n      return {\n        __toolSide: 'client',\n        ...config,\n        execute,\n      }\n    },\n  }\n\n  return definition\n}\n"],"names":[],"mappings":"AAsLO,SAAS,eAKd,QACwC;AACxC,QAAM,aAAqD;AAAA,IACzD,YAAY;AAAA,IACZ,GAAG;AAAA,IACH,OACE,SAGoC;AACpC,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,GAAG;AAAA,QACH;AAAA,MAAA;AAAA,IAEJ;AAAA,IAEA,OACE,SAGoC;AACpC,aAAO;AAAA,QACL,YAAY;AAAA,QACZ,GAAG;AAAA,QACH;AAAA,MAAA;AAAA,IAEJ;AAAA,EAAA;AAGF,SAAO;AACT;"}