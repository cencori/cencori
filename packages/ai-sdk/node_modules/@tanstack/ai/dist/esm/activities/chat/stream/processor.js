import { generateMessageId, uiMessageToModelMessages } from "../messages.js";
import { defaultJSONParser } from "./json-parser.js";
import { updateToolCallWithOutput, updateToolResultPart, updateToolCallApprovalResponse, updateToolCallPart, updateThinkingPart, updateToolCallApproval, updateTextPart } from "./message-updaters.js";
import { ImmediateStrategy } from "./strategies.js";
class StreamProcessor {
  constructor(options = {}) {
    this.messages = [];
    this.currentAssistantMessageId = null;
    this.totalTextContent = "";
    this.currentSegmentText = "";
    this.lastEmittedText = "";
    this.thinkingContent = "";
    this.toolCalls = /* @__PURE__ */ new Map();
    this.toolCallOrder = [];
    this.finishReason = null;
    this.isDone = false;
    this.hasToolCallsSinceTextStart = false;
    this.recording = null;
    this.recordingStartTime = 0;
    this.chunkStrategy = options.chunkStrategy || new ImmediateStrategy();
    this.events = options.events || {};
    this.handlers = options.handlers || {};
    this.jsonParser = options.jsonParser || defaultJSONParser;
    this.recordingEnabled = options.recording ?? false;
    if (options.initialMessages) {
      this.messages = [...options.initialMessages];
    }
  }
  // ============================================
  // Message Management Methods
  // ============================================
  /**
   * Set the messages array (e.g., from persisted state)
   */
  setMessages(messages) {
    this.messages = [...messages];
    this.emitMessagesChange();
  }
  /**
   * Add a user message to the conversation
   */
  addUserMessage(content) {
    const userMessage = {
      id: generateMessageId(),
      role: "user",
      parts: [{ type: "text", content }],
      createdAt: /* @__PURE__ */ new Date()
    };
    this.messages = [...this.messages, userMessage];
    this.emitMessagesChange();
    return userMessage;
  }
  /**
   * Start streaming a new assistant message
   * Returns the message ID
   */
  startAssistantMessage() {
    this.resetStreamState();
    const assistantMessage = {
      id: generateMessageId(),
      role: "assistant",
      parts: [],
      createdAt: /* @__PURE__ */ new Date()
    };
    this.currentAssistantMessageId = assistantMessage.id;
    this.messages = [...this.messages, assistantMessage];
    this.events.onStreamStart?.();
    this.emitMessagesChange();
    return assistantMessage.id;
  }
  /**
   * Add a tool result (called by client after handling onToolCall)
   */
  addToolResult(toolCallId, output, error) {
    const messageWithToolCall = this.messages.find(
      (msg) => msg.parts.some(
        (p) => p.type === "tool-call" && p.id === toolCallId
      )
    );
    if (!messageWithToolCall) {
      console.warn(
        `[StreamProcessor] Could not find message with tool call ${toolCallId}`
      );
      return;
    }
    let updatedMessages = updateToolCallWithOutput(
      this.messages,
      toolCallId,
      output,
      error ? "input-complete" : void 0,
      error
    );
    const content = typeof output === "string" ? output : JSON.stringify(output);
    const toolResultState = error ? "error" : "complete";
    updatedMessages = updateToolResultPart(
      updatedMessages,
      messageWithToolCall.id,
      toolCallId,
      content,
      toolResultState,
      error
    );
    this.messages = updatedMessages;
    this.emitMessagesChange();
  }
  /**
   * Add an approval response (called by client after handling onApprovalRequest)
   */
  addToolApprovalResponse(approvalId, approved) {
    this.messages = updateToolCallApprovalResponse(
      this.messages,
      approvalId,
      approved
    );
    this.emitMessagesChange();
  }
  /**
   * Get the conversation as ModelMessages (for sending to LLM)
   */
  toModelMessages() {
    const modelMessages = [];
    for (const msg of this.messages) {
      modelMessages.push(...uiMessageToModelMessages(msg));
    }
    return modelMessages;
  }
  /**
   * Get current messages
   */
  getMessages() {
    return this.messages;
  }
  /**
   * Check if all tool calls in the last assistant message are complete
   * Useful for auto-continue logic
   */
  areAllToolsComplete() {
    const lastAssistant = this.messages.findLast(
      (m) => m.role === "assistant"
    );
    if (!lastAssistant) return true;
    const toolParts = lastAssistant.parts.filter(
      (p) => p.type === "tool-call"
    );
    if (toolParts.length === 0) return true;
    return toolParts.every(
      (part) => part.state === "approval-responded" || part.output !== void 0 && !part.approval
    );
  }
  /**
   * Remove messages after a certain index (for reload/retry)
   */
  removeMessagesAfter(index) {
    this.messages = this.messages.slice(0, index + 1);
    this.emitMessagesChange();
  }
  /**
   * Clear all messages
   */
  clearMessages() {
    this.messages = [];
    this.currentAssistantMessageId = null;
    this.emitMessagesChange();
  }
  // ============================================
  // Stream Processing Methods
  // ============================================
  /**
   * Process a stream and emit events through handlers
   */
  async process(stream) {
    this.resetStreamState();
    if (this.recordingEnabled) {
      this.startRecording();
    }
    for await (const chunk of stream) {
      this.processChunk(chunk);
    }
    this.finalizeStream();
    if (this.recording) {
      this.recording.result = this.getResult();
    }
    return this.getResult();
  }
  /**
   * Process a single chunk from the stream
   */
  processChunk(chunk) {
    if (this.recording) {
      this.recording.chunks.push({
        chunk,
        timestamp: Date.now(),
        index: this.recording.chunks.length
      });
    }
    switch (chunk.type) {
      case "content":
        this.handleContentChunk(chunk);
        break;
      case "tool_call":
        this.handleToolCallChunk(chunk);
        break;
      case "tool_result":
        this.handleToolResultChunk(chunk);
        break;
      case "done":
        this.handleDoneChunk(chunk);
        break;
      case "error":
        this.handleErrorChunk(chunk);
        break;
      case "thinking":
        this.handleThinkingChunk(chunk);
        break;
      case "approval-requested":
        this.handleApprovalRequestedChunk(chunk);
        break;
      case "tool-input-available":
        this.handleToolInputAvailableChunk(chunk);
        break;
    }
  }
  /**
   * Handle a content chunk
   */
  handleContentChunk(chunk) {
    this.completeAllToolCalls();
    const previousSegment = this.currentSegmentText;
    const isNewSegment = this.hasToolCallsSinceTextStart && previousSegment.length > 0 && this.isNewTextSegment(chunk, previousSegment);
    if (isNewSegment) {
      if (previousSegment !== this.lastEmittedText) {
        this.emitTextUpdate();
      }
      this.currentSegmentText = "";
      this.lastEmittedText = "";
      this.hasToolCallsSinceTextStart = false;
    }
    const currentText = this.currentSegmentText;
    let nextText = currentText;
    if (chunk.delta !== "") {
      nextText = currentText + chunk.delta;
    } else if (chunk.content !== "") {
      if (chunk.content.startsWith(currentText)) {
        nextText = chunk.content;
      } else if (currentText.startsWith(chunk.content)) {
        nextText = currentText;
      } else {
        nextText = currentText + chunk.content;
      }
    }
    const textDelta = nextText.slice(currentText.length);
    this.currentSegmentText = nextText;
    this.totalTextContent += textDelta;
    const chunkPortion = chunk.delta ?? chunk.content ?? "";
    const shouldEmit = this.chunkStrategy.shouldEmit(
      chunkPortion,
      this.currentSegmentText
    );
    if (shouldEmit && this.currentSegmentText !== this.lastEmittedText) {
      this.emitTextUpdate();
    }
  }
  /**
   * Handle a tool call chunk
   */
  handleToolCallChunk(chunk) {
    this.hasToolCallsSinceTextStart = true;
    const toolCallId = chunk.toolCall.id;
    const existingToolCall = this.toolCalls.get(toolCallId);
    if (!existingToolCall) {
      const initialState = chunk.toolCall.function.arguments ? "input-streaming" : "awaiting-input";
      const newToolCall = {
        id: chunk.toolCall.id,
        name: chunk.toolCall.function.name,
        arguments: chunk.toolCall.function.arguments || "",
        state: initialState,
        parsedArguments: void 0,
        index: chunk.index
      };
      if (chunk.toolCall.function.arguments) {
        newToolCall.parsedArguments = this.jsonParser.parse(
          chunk.toolCall.function.arguments
        );
      }
      this.toolCalls.set(toolCallId, newToolCall);
      this.toolCallOrder.push(toolCallId);
      const actualIndex = this.toolCallOrder.indexOf(toolCallId);
      this.handlers.onToolCallStart?.(
        actualIndex,
        chunk.toolCall.id,
        chunk.toolCall.function.name
      );
      this.handlers.onToolCallStateChange?.(
        actualIndex,
        chunk.toolCall.id,
        chunk.toolCall.function.name,
        initialState,
        chunk.toolCall.function.arguments || "",
        newToolCall.parsedArguments
      );
      if (chunk.toolCall.function.arguments) {
        this.handlers.onToolCallDelta?.(
          actualIndex,
          chunk.toolCall.function.arguments
        );
      }
      if (this.currentAssistantMessageId) {
        this.messages = updateToolCallPart(
          this.messages,
          this.currentAssistantMessageId,
          {
            id: chunk.toolCall.id,
            name: chunk.toolCall.function.name,
            arguments: chunk.toolCall.function.arguments || "",
            state: initialState
          }
        );
        this.emitMessagesChange();
        this.events.onToolCallStateChange?.(
          this.currentAssistantMessageId,
          chunk.toolCall.id,
          initialState,
          chunk.toolCall.function.arguments || ""
        );
      }
    } else {
      const wasAwaitingInput = existingToolCall.state === "awaiting-input";
      existingToolCall.arguments += chunk.toolCall.function.arguments || "";
      if (wasAwaitingInput && chunk.toolCall.function.arguments) {
        existingToolCall.state = "input-streaming";
      }
      existingToolCall.parsedArguments = this.jsonParser.parse(
        existingToolCall.arguments
      );
      const actualIndex = this.toolCallOrder.indexOf(toolCallId);
      this.handlers.onToolCallStateChange?.(
        actualIndex,
        existingToolCall.id,
        existingToolCall.name,
        existingToolCall.state,
        existingToolCall.arguments,
        existingToolCall.parsedArguments
      );
      if (chunk.toolCall.function.arguments) {
        this.handlers.onToolCallDelta?.(
          actualIndex,
          chunk.toolCall.function.arguments
        );
      }
      if (this.currentAssistantMessageId) {
        this.messages = updateToolCallPart(
          this.messages,
          this.currentAssistantMessageId,
          {
            id: existingToolCall.id,
            name: existingToolCall.name,
            arguments: existingToolCall.arguments,
            state: existingToolCall.state
          }
        );
        this.emitMessagesChange();
        this.events.onToolCallStateChange?.(
          this.currentAssistantMessageId,
          existingToolCall.id,
          existingToolCall.state,
          existingToolCall.arguments
        );
      }
    }
  }
  /**
   * Handle a tool result chunk
   */
  handleToolResultChunk(chunk) {
    const state = "complete";
    this.handlers.onToolResultStateChange?.(
      chunk.toolCallId,
      chunk.content,
      state
    );
    if (this.currentAssistantMessageId) {
      this.messages = updateToolResultPart(
        this.messages,
        this.currentAssistantMessageId,
        chunk.toolCallId,
        chunk.content,
        state
      );
      this.emitMessagesChange();
    }
  }
  /**
   * Handle a done chunk
   */
  handleDoneChunk(chunk) {
    this.finishReason = chunk.finishReason;
    this.isDone = true;
    this.completeAllToolCalls();
  }
  /**
   * Handle an error chunk
   */
  handleErrorChunk(chunk) {
    this.handlers.onError?.(chunk.error);
    this.events.onError?.(new Error(chunk.error.message));
  }
  /**
   * Handle a thinking chunk
   */
  handleThinkingChunk(chunk) {
    const previous = this.thinkingContent;
    let nextThinking = previous;
    if (chunk.delta && chunk.delta !== "") {
      nextThinking = previous + chunk.delta;
    } else if (chunk.content !== "") {
      if (chunk.content.startsWith(previous)) {
        nextThinking = chunk.content;
      } else if (previous.startsWith(chunk.content)) {
        nextThinking = previous;
      } else {
        nextThinking = previous + chunk.content;
      }
    }
    this.thinkingContent = nextThinking;
    this.handlers.onThinkingUpdate?.(this.thinkingContent);
    if (this.currentAssistantMessageId) {
      this.messages = updateThinkingPart(
        this.messages,
        this.currentAssistantMessageId,
        this.thinkingContent
      );
      this.emitMessagesChange();
      this.events.onThinkingUpdate?.(
        this.currentAssistantMessageId,
        this.thinkingContent
      );
    }
  }
  /**
   * Handle an approval-requested chunk
   */
  handleApprovalRequestedChunk(chunk) {
    this.handlers.onApprovalRequested?.(
      chunk.toolCallId,
      chunk.toolName,
      chunk.input,
      chunk.approval.id
    );
    if (this.currentAssistantMessageId) {
      this.messages = updateToolCallApproval(
        this.messages,
        this.currentAssistantMessageId,
        chunk.toolCallId,
        chunk.approval.id
      );
      this.emitMessagesChange();
    }
    this.events.onApprovalRequest?.({
      toolCallId: chunk.toolCallId,
      toolName: chunk.toolName,
      input: chunk.input,
      approvalId: chunk.approval.id
    });
  }
  /**
   * Handle a tool-input-available chunk
   */
  handleToolInputAvailableChunk(chunk) {
    this.handlers.onToolInputAvailable?.(
      chunk.toolCallId,
      chunk.toolName,
      chunk.input
    );
    this.events.onToolCall?.({
      toolCallId: chunk.toolCallId,
      toolName: chunk.toolName,
      input: chunk.input
    });
  }
  /**
   * Detect if an incoming content chunk represents a NEW text segment
   */
  isNewTextSegment(chunk, previous) {
    if (chunk.delta !== void 0 && chunk.content !== void 0) {
      if (chunk.content.length < previous.length) {
        return true;
      }
      if (!chunk.content.startsWith(previous) && !previous.startsWith(chunk.content)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Complete all tool calls
   */
  completeAllToolCalls() {
    this.toolCalls.forEach((toolCall, id) => {
      if (toolCall.state !== "input-complete") {
        const index = this.toolCallOrder.indexOf(id);
        this.completeToolCall(index, toolCall);
      }
    });
  }
  /**
   * Mark a tool call as complete and emit event
   */
  completeToolCall(index, toolCall) {
    toolCall.state = "input-complete";
    toolCall.parsedArguments = this.jsonParser.parse(toolCall.arguments);
    this.handlers.onToolCallStateChange?.(
      index,
      toolCall.id,
      toolCall.name,
      "input-complete",
      toolCall.arguments,
      toolCall.parsedArguments
    );
    this.handlers.onToolCallComplete?.(
      index,
      toolCall.id,
      toolCall.name,
      toolCall.arguments
    );
    if (this.currentAssistantMessageId) {
      this.messages = updateToolCallPart(
        this.messages,
        this.currentAssistantMessageId,
        {
          id: toolCall.id,
          name: toolCall.name,
          arguments: toolCall.arguments,
          state: "input-complete"
        }
      );
      this.emitMessagesChange();
      this.events.onToolCallStateChange?.(
        this.currentAssistantMessageId,
        toolCall.id,
        "input-complete",
        toolCall.arguments
      );
    }
  }
  /**
   * Emit pending text update
   */
  emitTextUpdate() {
    this.lastEmittedText = this.currentSegmentText;
    this.handlers.onTextUpdate?.(this.currentSegmentText);
    if (this.currentAssistantMessageId) {
      this.messages = updateTextPart(
        this.messages,
        this.currentAssistantMessageId,
        this.currentSegmentText
      );
      this.emitMessagesChange();
      this.events.onTextUpdate?.(
        this.currentAssistantMessageId,
        this.currentSegmentText
      );
    }
  }
  /**
   * Emit messages change event
   */
  emitMessagesChange() {
    this.events.onMessagesChange?.([...this.messages]);
  }
  /**
   * Finalize the stream - complete all pending operations
   */
  finalizeStream() {
    this.completeAllToolCalls();
    if (this.currentSegmentText !== this.lastEmittedText) {
      this.emitTextUpdate();
    }
    const toolCalls = this.getCompletedToolCalls();
    this.handlers.onStreamEnd?.(
      this.totalTextContent,
      toolCalls.length > 0 ? toolCalls : void 0
    );
    if (this.currentAssistantMessageId) {
      const assistantMessage = this.messages.find(
        (m) => m.id === this.currentAssistantMessageId
      );
      if (assistantMessage) {
        this.events.onStreamEnd?.(assistantMessage);
      }
    }
  }
  /**
   * Get completed tool calls in API format
   */
  getCompletedToolCalls() {
    return Array.from(this.toolCalls.values()).filter((tc) => tc.state === "input-complete").map((tc) => ({
      id: tc.id,
      type: "function",
      function: {
        name: tc.name,
        arguments: tc.arguments
      }
    }));
  }
  /**
   * Get current result
   */
  getResult() {
    const toolCalls = this.getCompletedToolCalls();
    return {
      content: this.totalTextContent,
      thinking: this.thinkingContent || void 0,
      toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
      finishReason: this.finishReason
    };
  }
  /**
   * Get current processor state (legacy)
   */
  getState() {
    return {
      content: this.totalTextContent,
      thinking: this.thinkingContent,
      toolCalls: new Map(this.toolCalls),
      toolCallOrder: [...this.toolCallOrder],
      finishReason: this.finishReason,
      done: this.isDone
    };
  }
  /**
   * Start recording chunks
   */
  startRecording() {
    this.recordingEnabled = true;
    this.recordingStartTime = Date.now();
    this.recording = {
      version: "1.0",
      timestamp: this.recordingStartTime,
      chunks: []
    };
  }
  /**
   * Get the current recording
   */
  getRecording() {
    return this.recording;
  }
  /**
   * Reset stream state (but keep messages)
   */
  resetStreamState() {
    this.totalTextContent = "";
    this.currentSegmentText = "";
    this.lastEmittedText = "";
    this.thinkingContent = "";
    this.toolCalls.clear();
    this.toolCallOrder = [];
    this.finishReason = null;
    this.isDone = false;
    this.hasToolCallsSinceTextStart = false;
    this.chunkStrategy.reset?.();
  }
  /**
   * Full reset (including messages)
   */
  reset() {
    this.resetStreamState();
    this.messages = [];
    this.currentAssistantMessageId = null;
  }
  /**
   * Replay a recording through the processor
   */
  static async replay(recording, options) {
    const processor = new StreamProcessor(options);
    return processor.process(createReplayStream(recording));
  }
}
function createReplayStream(recording) {
  return {
    // eslint-disable-next-line @typescript-eslint/require-await
    async *[Symbol.asyncIterator]() {
      for (const { chunk } of recording.chunks) {
        yield chunk;
      }
    }
  };
}
export {
  StreamProcessor,
  createReplayStream
};
//# sourceMappingURL=processor.js.map
