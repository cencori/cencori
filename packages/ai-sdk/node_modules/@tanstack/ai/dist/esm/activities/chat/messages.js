function getTextContent(content) {
  if (content === null) {
    return "";
  }
  if (typeof content === "string") {
    return content;
  }
  return content.filter((part) => part.type === "text").map((part) => part.content).join("");
}
function convertMessagesToModelMessages(messages) {
  const modelMessages = [];
  for (const msg of messages) {
    if ("parts" in msg) {
      modelMessages.push(...uiMessageToModelMessages(msg));
    } else {
      modelMessages.push(msg);
    }
  }
  return modelMessages;
}
function uiMessageToModelMessages(uiMessage) {
  const messageList = [];
  if (uiMessage.role === "system") {
    return messageList;
  }
  const textParts = [];
  const toolCallParts = [];
  const toolResultParts = [];
  for (const part of uiMessage.parts) {
    if (part.type === "text") {
      textParts.push(part);
    } else if (part.type === "tool-call") {
      toolCallParts.push(part);
    } else if (part.type === "tool-result") {
      toolResultParts.push(part);
    }
  }
  const content = textParts.map((p) => p.content).join("") || null;
  const toolCalls = toolCallParts.length > 0 ? toolCallParts.filter(
    (p) => p.state === "input-complete" || p.state === "approval-responded" || p.output !== void 0
    // Include if has output (client tool result)
  ).map((p) => ({
    id: p.id,
    type: "function",
    function: {
      name: p.name,
      arguments: p.arguments
    }
  })) : void 0;
  if (uiMessage.role !== "assistant" || content || !toolCalls) {
    messageList.push({
      role: uiMessage.role,
      content,
      ...toolCalls && toolCalls.length > 0 && { toolCalls }
    });
  } else if (toolCalls.length > 0) {
    messageList.push({
      role: "assistant",
      content,
      toolCalls
    });
  }
  for (const toolResultPart of toolResultParts) {
    if (toolResultPart.state === "complete" || toolResultPart.state === "error") {
      messageList.push({
        role: "tool",
        content: toolResultPart.content,
        toolCallId: toolResultPart.toolCallId
      });
    }
  }
  return messageList;
}
function modelMessageToUIMessage(modelMessage, id) {
  const parts = [];
  const textContent = getTextContent(modelMessage.content);
  if (textContent) {
    parts.push({
      type: "text",
      content: textContent
    });
  }
  if (modelMessage.toolCalls && modelMessage.toolCalls.length > 0) {
    for (const toolCall of modelMessage.toolCalls) {
      parts.push({
        type: "tool-call",
        id: toolCall.id,
        name: toolCall.function.name,
        arguments: toolCall.function.arguments,
        state: "input-complete"
        // Model messages have complete arguments
      });
    }
  }
  if (modelMessage.role === "tool" && modelMessage.toolCallId) {
    parts.push({
      type: "tool-result",
      toolCallId: modelMessage.toolCallId,
      content: getTextContent(modelMessage.content),
      state: "complete"
    });
  }
  return {
    id: id || generateMessageId(),
    role: modelMessage.role === "tool" ? "assistant" : modelMessage.role,
    parts
  };
}
function modelMessagesToUIMessages(modelMessages) {
  const uiMessages = [];
  let currentAssistantMessage = null;
  for (const msg of modelMessages) {
    if (msg.role === "tool") {
      if (currentAssistantMessage && currentAssistantMessage.role === "assistant") {
        currentAssistantMessage.parts.push({
          type: "tool-result",
          toolCallId: msg.toolCallId,
          content: getTextContent(msg.content),
          state: "complete"
        });
      } else {
        const toolResultUIMessage = modelMessageToUIMessage(msg);
        uiMessages.push(toolResultUIMessage);
      }
    } else {
      const uiMessage = modelMessageToUIMessage(msg);
      uiMessages.push(uiMessage);
      if (msg.role === "assistant") {
        currentAssistantMessage = uiMessage;
      } else {
        currentAssistantMessage = null;
      }
    }
  }
  return uiMessages;
}
function normalizeToUIMessage(message, generateId) {
  if ("parts" in message) {
    return {
      ...message,
      id: message.id || generateId(),
      createdAt: message.createdAt || /* @__PURE__ */ new Date()
    };
  } else {
    return {
      ...modelMessageToUIMessage(message, generateId()),
      createdAt: /* @__PURE__ */ new Date()
    };
  }
}
function generateMessageId() {
  return `msg-${Date.now()}-${Math.random().toString(36).substring(7)}`;
}
export {
  convertMessagesToModelMessages,
  generateMessageId,
  modelMessageToUIMessage,
  modelMessagesToUIMessages,
  normalizeToUIMessage,
  uiMessageToModelMessages
};
//# sourceMappingURL=messages.js.map
