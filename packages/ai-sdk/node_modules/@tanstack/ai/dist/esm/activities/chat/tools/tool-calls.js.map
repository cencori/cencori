{"version":3,"file":"tool-calls.js","sources":["../../../../../src/activities/chat/tools/tool-calls.ts"],"sourcesContent":["import { isStandardSchema, parseWithStandardSchema } from './schema-converter'\nimport type {\n  DoneStreamChunk,\n  ModelMessage,\n  Tool,\n  ToolCall,\n  ToolResultStreamChunk,\n} from '../../../types'\n\n/**\n * Manages tool call accumulation and execution for the chat() method's automatic tool execution loop.\n *\n * Responsibilities:\n * - Accumulates streaming tool call chunks (ID, name, arguments)\n * - Validates tool calls (filters out incomplete ones)\n * - Executes tool `execute` functions with parsed arguments\n * - Emits `tool_result` chunks for client visibility\n * - Returns tool result messages for conversation history\n *\n * This class is used internally by the AI.chat() method to handle the automatic\n * tool execution loop. It can also be used independently for custom tool execution logic.\n *\n * @example\n * ```typescript\n * const manager = new ToolCallManager(tools);\n *\n * // During streaming, accumulate tool calls\n * for await (const chunk of stream) {\n *   if (chunk.type === \"tool_call\") {\n *     manager.addToolCallChunk(chunk);\n *   }\n * }\n *\n * // After stream completes, execute tools\n * if (manager.hasToolCalls()) {\n *   const toolResults = yield* manager.executeTools(doneChunk);\n *   messages = [...messages, ...toolResults];\n *   manager.clear();\n * }\n * ```\n */\nexport class ToolCallManager {\n  private toolCallsMap = new Map<number, ToolCall>()\n  private tools: ReadonlyArray<Tool>\n\n  constructor(tools: ReadonlyArray<Tool>) {\n    this.tools = tools\n  }\n\n  /**\n   * Add a tool call chunk to the accumulator\n   * Handles streaming tool calls by accumulating arguments\n   */\n  addToolCallChunk(chunk: {\n    toolCall: {\n      id: string\n      type: 'function'\n      function: {\n        name: string\n        arguments: string\n      }\n    }\n    index: number\n  }): void {\n    const index = chunk.index\n    const existing = this.toolCallsMap.get(index)\n\n    if (!existing) {\n      // Only create entry if we have a tool call ID and name\n      if (chunk.toolCall.id && chunk.toolCall.function.name) {\n        this.toolCallsMap.set(index, {\n          id: chunk.toolCall.id,\n          type: 'function',\n          function: {\n            name: chunk.toolCall.function.name,\n            arguments: chunk.toolCall.function.arguments || '',\n          },\n        })\n      }\n    } else {\n      // Update name if it wasn't set before\n      if (chunk.toolCall.function.name && !existing.function.name) {\n        existing.function.name = chunk.toolCall.function.name\n      }\n      // Accumulate arguments for streaming tool calls\n      if (chunk.toolCall.function.arguments) {\n        existing.function.arguments += chunk.toolCall.function.arguments\n      }\n    }\n  }\n\n  /**\n   * Check if there are any complete tool calls to execute\n   */\n  hasToolCalls(): boolean {\n    return this.getToolCalls().length > 0\n  }\n\n  /**\n   * Get all complete tool calls (filtered for valid ID and name)\n   */\n  getToolCalls(): Array<ToolCall> {\n    return Array.from(this.toolCallsMap.values()).filter(\n      (tc) => tc.id && tc.function.name && tc.function.name.trim().length > 0,\n    )\n  }\n\n  /**\n   * Execute all tool calls and return tool result messages\n   * Also yields tool_result chunks for streaming\n   */\n  async *executeTools(\n    doneChunk: DoneStreamChunk,\n  ): AsyncGenerator<ToolResultStreamChunk, Array<ModelMessage>, void> {\n    const toolCallsArray = this.getToolCalls()\n    const toolResults: Array<ModelMessage> = []\n\n    for (const toolCall of toolCallsArray) {\n      const tool = this.tools.find((t) => t.name === toolCall.function.name)\n\n      let toolResultContent: string\n      if (tool?.execute) {\n        try {\n          // Parse arguments\n          let args: unknown\n          try {\n            args = JSON.parse(toolCall.function.arguments)\n          } catch (parseError) {\n            throw new Error(\n              `Failed to parse tool arguments as JSON: ${toolCall.function.arguments}`,\n            )\n          }\n\n          // Validate input against inputSchema (for Standard Schema compliant schemas)\n          if (tool.inputSchema && isStandardSchema(tool.inputSchema)) {\n            try {\n              args = parseWithStandardSchema(tool.inputSchema, args)\n            } catch (validationError: unknown) {\n              const message =\n                validationError instanceof Error\n                  ? validationError.message\n                  : 'Validation failed'\n              throw new Error(\n                `Input validation failed for tool ${tool.name}: ${message}`,\n              )\n            }\n          }\n\n          // Execute the tool\n          let result = await tool.execute(args)\n\n          // Validate output against outputSchema if provided (for Standard Schema compliant schemas)\n          if (\n            tool.outputSchema &&\n            isStandardSchema(tool.outputSchema) &&\n            result !== undefined &&\n            result !== null\n          ) {\n            try {\n              result = parseWithStandardSchema(tool.outputSchema, result)\n            } catch (validationError: unknown) {\n              const message =\n                validationError instanceof Error\n                  ? validationError.message\n                  : 'Validation failed'\n              throw new Error(\n                `Output validation failed for tool ${tool.name}: ${message}`,\n              )\n            }\n          }\n\n          toolResultContent =\n            typeof result === 'string' ? result : JSON.stringify(result)\n        } catch (error: unknown) {\n          // If tool execution fails, add error message\n          const message =\n            error instanceof Error ? error.message : 'Unknown error'\n          toolResultContent = `Error executing tool: ${message}`\n        }\n      } else {\n        // Tool doesn't have execute function, add placeholder\n        toolResultContent = `Tool ${toolCall.function.name} does not have an execute function`\n      }\n\n      // Emit tool_result chunk so callers can track tool execution\n      yield {\n        type: 'tool_result',\n        id: doneChunk.id,\n        model: doneChunk.model,\n        timestamp: Date.now(),\n        toolCallId: toolCall.id,\n        content: toolResultContent,\n      }\n\n      // Add tool result message\n      toolResults.push({\n        role: 'tool',\n        content: toolResultContent,\n        toolCallId: toolCall.id,\n      })\n    }\n\n    return toolResults\n  }\n\n  /**\n   * Clear the tool calls map for the next iteration\n   */\n  clear(): void {\n    this.toolCallsMap.clear()\n  }\n}\n\nexport interface ToolResult {\n  toolCallId: string\n  toolName: string\n  result: any\n  state?: 'output-available' | 'output-error'\n  /** Duration of tool execution in milliseconds (only for server-executed tools) */\n  duration?: number\n}\n\nexport interface ApprovalRequest {\n  toolCallId: string\n  toolName: string\n  input: any\n  approvalId: string\n}\n\nexport interface ClientToolRequest {\n  toolCallId: string\n  toolName: string\n  input: any\n}\n\ninterface ExecuteToolCallsResult {\n  /** Tool results ready to send to LLM */\n  results: Array<ToolResult>\n  /** Tools that need user approval before execution */\n  needsApproval: Array<ApprovalRequest>\n  /** Tools that need client-side execution */\n  needsClientExecution: Array<ClientToolRequest>\n}\n\n/**\n * Execute tool calls based on their configuration\n *\n * Handles three cases:\n * 1. Client tools (no execute) - request client to execute\n * 2. Server tools with approval - check approval before executing\n * 3. Normal server tools - execute immediately\n *\n * @param toolCalls - Tool calls from the LLM\n * @param tools - Available tools with their configurations\n * @param approvals - Map of approval decisions (approval.id -> approved boolean)\n * @param clientResults - Map of client-side execution results (toolCallId -> result)\n */\nexport async function executeToolCalls(\n  toolCalls: Array<ToolCall>,\n  tools: ReadonlyArray<Tool>,\n  approvals: Map<string, boolean> = new Map(),\n  clientResults: Map<string, any> = new Map(),\n): Promise<ExecuteToolCallsResult> {\n  const results: Array<ToolResult> = []\n  const needsApproval: Array<ApprovalRequest> = []\n  const needsClientExecution: Array<ClientToolRequest> = []\n\n  // Create tool lookup map\n  const toolMap = new Map<string, Tool>()\n  for (const tool of tools) {\n    toolMap.set(tool.name, tool)\n  }\n\n  for (const toolCall of toolCalls) {\n    const tool = toolMap.get(toolCall.function.name)\n    const toolName = toolCall.function.name\n\n    if (!tool) {\n      // Unknown tool - return error\n      results.push({\n        toolCallId: toolCall.id,\n        toolName,\n        result: { error: `Unknown tool: ${toolName}` },\n        state: 'output-error',\n      })\n      continue\n    }\n\n    // Parse arguments, throwing error if invalid JSON\n    let input: unknown = {}\n    const argsStr = toolCall.function.arguments.trim() || '{}'\n    if (argsStr) {\n      try {\n        input = JSON.parse(argsStr)\n      } catch (parseError) {\n        // If parsing fails, throw error to fail fast\n        throw new Error(`Failed to parse tool arguments as JSON: ${argsStr}`)\n      }\n    }\n\n    // Validate input against inputSchema (for Standard Schema compliant schemas)\n    if (tool.inputSchema && isStandardSchema(tool.inputSchema)) {\n      try {\n        input = parseWithStandardSchema(tool.inputSchema, input)\n      } catch (validationError: unknown) {\n        const message =\n          validationError instanceof Error\n            ? validationError.message\n            : 'Validation failed'\n        results.push({\n          toolCallId: toolCall.id,\n          toolName,\n          result: {\n            error: `Input validation failed for tool ${tool.name}: ${message}`,\n          },\n          state: 'output-error',\n        })\n        continue\n      }\n    }\n\n    // CASE 1: Client-side tool (no execute function)\n    if (!tool.execute) {\n      // Check if tool needs approval\n      if (tool.needsApproval) {\n        const approvalId = `approval_${toolCall.id}`\n\n        // Check if approval decision exists\n        if (approvals.has(approvalId)) {\n          const approved = approvals.get(approvalId)\n\n          if (approved) {\n            // Approved - check if client has executed\n            if (clientResults.has(toolCall.id)) {\n              results.push({\n                toolCallId: toolCall.id,\n                toolName,\n                result: clientResults.get(toolCall.id),\n              })\n            } else {\n              // Approved but not executed yet - request client execution\n              needsClientExecution.push({\n                toolCallId: toolCall.id,\n                toolName,\n                input,\n              })\n            }\n          } else {\n            // User declined\n            results.push({\n              toolCallId: toolCall.id,\n              toolName,\n              result: { error: 'User declined tool execution' },\n              state: 'output-error',\n            })\n          }\n        } else {\n          // Need approval first\n          needsApproval.push({\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            input,\n            approvalId,\n          })\n        }\n      } else {\n        // No approval needed - check if client has executed\n        if (clientResults.has(toolCall.id)) {\n          results.push({\n            toolCallId: toolCall.id,\n            toolName,\n            result: clientResults.get(toolCall.id),\n          })\n        } else {\n          // Request client execution\n          needsClientExecution.push({\n            toolCallId: toolCall.id,\n            toolName,\n            input,\n          })\n        }\n      }\n      continue\n    }\n\n    // CASE 2: Server tool with approval required\n    if (tool.needsApproval) {\n      const approvalId = `approval_${toolCall.id}`\n\n      // Check if approval decision exists\n      if (approvals.has(approvalId)) {\n        const approved = approvals.get(approvalId)\n\n        if (approved) {\n          // Execute after approval\n          const startTime = Date.now()\n          try {\n            let result = await tool.execute(input)\n            const duration = Date.now() - startTime\n\n            // Validate output against outputSchema if provided (for Standard Schema compliant schemas)\n            if (\n              tool.outputSchema &&\n              isStandardSchema(tool.outputSchema) &&\n              result !== undefined &&\n              result !== null\n            ) {\n              result = parseWithStandardSchema(tool.outputSchema, result)\n            }\n\n            results.push({\n              toolCallId: toolCall.id,\n              toolName,\n              result:\n                typeof result === 'string'\n                  ? JSON.parse(result)\n                  : result || null,\n              duration,\n            })\n          } catch (error: unknown) {\n            const duration = Date.now() - startTime\n            const message =\n              error instanceof Error ? error.message : 'Unknown error'\n            results.push({\n              toolCallId: toolCall.id,\n              toolName,\n              result: { error: message },\n              state: 'output-error',\n              duration,\n            })\n          }\n        } else {\n          // User declined\n          results.push({\n            toolCallId: toolCall.id,\n            toolName,\n            result: { error: 'User declined tool execution' },\n            state: 'output-error',\n          })\n        }\n      } else {\n        // Need approval\n        needsApproval.push({\n          toolCallId: toolCall.id,\n          toolName,\n          input,\n          approvalId,\n        })\n      }\n      continue\n    }\n\n    // CASE 3: Normal server tool - execute immediately\n    const startTime = Date.now()\n    try {\n      let result = await tool.execute(input)\n      const duration = Date.now() - startTime\n\n      // Validate output against outputSchema if provided (for Standard Schema compliant schemas)\n      if (\n        tool.outputSchema &&\n        isStandardSchema(tool.outputSchema) &&\n        result !== undefined &&\n        result !== null\n      ) {\n        result = parseWithStandardSchema(tool.outputSchema, result)\n      }\n\n      results.push({\n        toolCallId: toolCall.id,\n        toolName,\n        result:\n          typeof result === 'string' ? JSON.parse(result) : result || null,\n        duration,\n      })\n    } catch (error: unknown) {\n      const duration = Date.now() - startTime\n      const message = error instanceof Error ? error.message : 'Unknown error'\n      results.push({\n        toolCallId: toolCall.id,\n        toolName,\n        result: { error: message },\n        state: 'output-error',\n        duration,\n      })\n    }\n  }\n\n  return { results, needsApproval, needsClientExecution }\n}\n"],"names":["startTime"],"mappings":"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"}