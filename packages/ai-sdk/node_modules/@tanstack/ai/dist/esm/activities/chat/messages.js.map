{"version":3,"file":"messages.js","sources":["../../../../src/activities/chat/messages.ts"],"sourcesContent":["import type {\n  ContentPart,\n  MessagePart,\n  ModelMessage,\n  TextPart,\n  ToolCallPart,\n  ToolResultPart,\n  UIMessage,\n} from '../../types'\n// ===========================\n// Message Converters\n// ===========================\n\n/**\n * Helper to extract text content from string or ContentPart array\n * For multimodal content, this extracts only the text parts\n */\nfunction getTextContent(content: string | null | Array<ContentPart>): string {\n  if (content === null) {\n    return ''\n  }\n  if (typeof content === 'string') {\n    return content\n  }\n  // Extract text from ContentPart array\n  return content\n    .filter((part) => part.type === 'text')\n    .map((part) => part.content)\n    .join('')\n}\n\n/**\n * Convert UIMessages or ModelMessages to ModelMessages\n */\nexport function convertMessagesToModelMessages(\n  messages: Array<UIMessage | ModelMessage>,\n): Array<ModelMessage> {\n  const modelMessages: Array<ModelMessage> = []\n  for (const msg of messages) {\n    if ('parts' in msg) {\n      // UIMessage - convert to ModelMessages\n      modelMessages.push(...uiMessageToModelMessages(msg))\n    } else {\n      // Already ModelMessage\n      modelMessages.push(msg)\n    }\n  }\n  return modelMessages\n}\n\n/**\n * Convert a UIMessage to ModelMessage(s)\n *\n * This conversion handles the parts-based structure:\n * - Text parts → content field\n * - ToolCall parts → toolCalls array\n * - ToolResult parts → separate role=\"tool\" messages\n *\n * @param uiMessage - The UIMessage to convert\n * @returns An array of ModelMessages (may be multiple if tool results are present)\n */\nexport function uiMessageToModelMessages(\n  uiMessage: UIMessage,\n): Array<ModelMessage> {\n  const messageList: Array<ModelMessage> = []\n\n  // Skip system messages - they're handled via systemPrompts, not ModelMessages\n  if (uiMessage.role === 'system') {\n    return messageList\n  }\n\n  // Separate parts by type\n  // Note: thinking parts are UI-only and not included in ModelMessages\n  const textParts: Array<TextPart> = []\n  const toolCallParts: Array<ToolCallPart> = []\n  const toolResultParts: Array<ToolResultPart> = []\n\n  for (const part of uiMessage.parts) {\n    if (part.type === 'text') {\n      textParts.push(part)\n    } else if (part.type === 'tool-call') {\n      toolCallParts.push(part)\n    } else if (part.type === 'tool-result') {\n      toolResultParts.push(part)\n    }\n    // thinking parts are skipped - they're UI-only\n  }\n\n  // Build the main message (user or assistant)\n  const content = textParts.map((p) => p.content).join('') || null\n  const toolCalls =\n    toolCallParts.length > 0\n      ? toolCallParts\n          .filter(\n            (p) =>\n              p.state === 'input-complete' ||\n              p.state === 'approval-responded' ||\n              p.output !== undefined, // Include if has output (client tool result)\n          )\n          .map((p) => ({\n            id: p.id,\n            type: 'function' as const,\n            function: {\n              name: p.name,\n              arguments: p.arguments,\n            },\n          }))\n      : undefined\n\n  // Create the main message\n  if (uiMessage.role !== 'assistant' || content || !toolCalls) {\n    messageList.push({\n      role: uiMessage.role,\n      content,\n      ...(toolCalls && toolCalls.length > 0 && { toolCalls }),\n    })\n  } else if (toolCalls.length > 0) {\n    // Assistant message with only tool calls\n    messageList.push({\n      role: 'assistant',\n      content,\n      toolCalls,\n    })\n  }\n\n  // Add tool result messages (only completed ones)\n  for (const toolResultPart of toolResultParts) {\n    if (\n      toolResultPart.state === 'complete' ||\n      toolResultPart.state === 'error'\n    ) {\n      messageList.push({\n        role: 'tool',\n        content: toolResultPart.content,\n        toolCallId: toolResultPart.toolCallId,\n      })\n    }\n  }\n\n  return messageList\n}\n\n/**\n * Convert a ModelMessage to UIMessage\n *\n * This conversion creates a parts-based structure:\n * - content field → TextPart\n * - toolCalls array → ToolCallPart[]\n * - role=\"tool\" messages should be converted separately and merged\n *\n * @param modelMessage - The ModelMessage to convert\n * @param id - Optional ID for the UIMessage (generated if not provided)\n * @returns A UIMessage with parts\n */\nexport function modelMessageToUIMessage(\n  modelMessage: ModelMessage,\n  id?: string,\n): UIMessage {\n  const parts: Array<MessagePart> = []\n\n  // Handle content (convert multimodal content to text for UI)\n  const textContent = getTextContent(modelMessage.content)\n  if (textContent) {\n    parts.push({\n      type: 'text',\n      content: textContent,\n    })\n  }\n\n  // Handle tool calls\n  if (modelMessage.toolCalls && modelMessage.toolCalls.length > 0) {\n    for (const toolCall of modelMessage.toolCalls) {\n      parts.push({\n        type: 'tool-call',\n        id: toolCall.id,\n        name: toolCall.function.name,\n        arguments: toolCall.function.arguments,\n        state: 'input-complete', // Model messages have complete arguments\n      })\n    }\n  }\n\n  // Handle tool results (when role is \"tool\")\n  if (modelMessage.role === 'tool' && modelMessage.toolCallId) {\n    parts.push({\n      type: 'tool-result',\n      toolCallId: modelMessage.toolCallId,\n      content: getTextContent(modelMessage.content),\n      state: 'complete',\n    })\n  }\n\n  return {\n    id: id || generateMessageId(),\n    role: modelMessage.role === 'tool' ? 'assistant' : modelMessage.role,\n    parts,\n  }\n}\n\n/**\n * Convert an array of ModelMessages to UIMessages\n *\n * This handles merging tool result messages with their corresponding assistant messages\n *\n * @param modelMessages - Array of ModelMessages to convert\n * @returns Array of UIMessages\n */\nexport function modelMessagesToUIMessages(\n  modelMessages: Array<ModelMessage>,\n): Array<UIMessage> {\n  const uiMessages: Array<UIMessage> = []\n  let currentAssistantMessage: UIMessage | null = null\n\n  for (const msg of modelMessages) {\n    if (msg.role === 'tool') {\n      // Tool result - merge into the last assistant message if possible\n      if (\n        currentAssistantMessage &&\n        currentAssistantMessage.role === 'assistant'\n      ) {\n        currentAssistantMessage.parts.push({\n          type: 'tool-result',\n          toolCallId: msg.toolCallId!,\n          content: getTextContent(msg.content),\n          state: 'complete',\n        })\n      } else {\n        // No assistant message to merge into, create a standalone one\n        const toolResultUIMessage = modelMessageToUIMessage(msg)\n        uiMessages.push(toolResultUIMessage)\n      }\n    } else {\n      // Regular message\n      const uiMessage = modelMessageToUIMessage(msg)\n      uiMessages.push(uiMessage)\n\n      // Track assistant messages for potential tool result merging\n      if (msg.role === 'assistant') {\n        currentAssistantMessage = uiMessage\n      } else {\n        currentAssistantMessage = null\n      }\n    }\n  }\n\n  return uiMessages\n}\n\n/**\n * Normalize a message (UIMessage or ModelMessage) to a UIMessage\n * Ensures the message has an ID and createdAt timestamp\n *\n * @param message - Either a UIMessage or ModelMessage\n * @param generateId - Function to generate a message ID if needed\n * @returns A UIMessage with guaranteed id and createdAt\n */\nexport function normalizeToUIMessage(\n  message: UIMessage | ModelMessage,\n  generateId: () => string,\n): UIMessage {\n  if ('parts' in message) {\n    // Already a UIMessage\n    return {\n      ...message,\n      id: message.id || generateId(),\n      createdAt: message.createdAt || new Date(),\n    }\n  } else {\n    // ModelMessage - convert to UIMessage\n    return {\n      ...modelMessageToUIMessage(message, generateId()),\n      createdAt: new Date(),\n    }\n  }\n}\n\n/**\n * Generate a unique message ID\n */\nexport function generateMessageId(): string {\n  return `msg-${Date.now()}-${Math.random().toString(36).substring(7)}`\n}\n"],"names":[],"mappings":"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"}